1. 포인터와 값 리시버 이해
    // 현재 위에서 정의한 메서드는 포인터 리시버임
	// 하지만 저 메서드를 사용하기 위해서 바로 위의 코드처럼
	// *Supplier 타입으로 만들 필요가 없음
	// => Supplier라고 해도 문제없이 사용 가능함
	//    => Go가 알아서 주소값을 취하여
	//    => 값 복사 없이 진행됨

	suppliersTest := []Supplier{
		{"kayak", "WaterSports"},
		{"ship", "sea"},
	}
	for _, sup := range suppliersTest {
		sup.printDetalis()
	}

	// 반대로 값 리시버를 가진 메서드를 사용 시
	// &형태로 정의한 포인터 변수에서
	// 해당 메서드를 부르면
	// => Go가 알아서 역참조하여
	//    => 값 복사되어 메서드가 실행됨

    즉, 
    원하는 방식대로 리시버를 정의하고
    부를 때는 값 변수든, 포인터 변수든 부르면 동일한 처리를 함

1-1. 리시버 타입을 사용한 메서드 호출
    // 리시버 타입을 통해 메서드 호출이 가능한데,
	// 1. 리시버가 값 타입인 경우
	Supplier.testMethod(Supplier{"boat", "sea"})

	// 2. 리시버가 포인터 타입인 경우
	//    : 포인터 타입을 통해 호출하고, 포인터 인수를 전달해야 함
	(*Supplier).printDetalis(&Supplier{"boat", "sea"})

	// 포인터 타입을 통한 호출 시
	// 4번과 달리 자동 변환 처리가 안됨
	// => 철저히 따라야함


###### 인터페이스

1. 포인터 메서드 리시버 효과 이해
	// 현재 인터페이스를 (p Product) 로 구현하고 있음 - 값 타입
	// => Expose 인터페이스에는 값 또는 포인터 타입이 들어갈 수 있음
	// 인터페이스를 (p *Product) 로 구현할 경우 - 포인터 타입
	// => 값 타입은 들어갈 수 없게 됨
	// 메서드로 들어갈 땐 값이 복사되었지만,
	// Interface 자체에는 구현체에 대한 참조가 가능한데
	// 인터페이스 타입에 대한 변경없이 주소값만 넣어주면 참조가 바로 발동함
	// => 코드 균일성 증가

2. 타입 단언
   : 인터페이스에서만 사용 가능한 구현체 가져오기
   - 인터페이스는 구현체의 구현 함수에만 접근 가능한데,
     실제 구현체를 가져와서 값 접근을 가능하게 함
     // for _, expense := range expense3 {
	 //  p, ok := expense.(Product) // 타입 단언
	 //	 if !ok {
	 //		fmt.Println(p.name, p.category, p.price)
     //  }
	 // }