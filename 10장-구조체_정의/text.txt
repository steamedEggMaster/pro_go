1. 구조체는 const 정의가 불가능하다 (필드 + 구조체 전부)

2. 구조체 초기화할 때 필드 위치 방법을 사용 시
   모든 필드를 채워줘야 함

3. 임베디드 필드는 타입이 구조체인 경우 유용하다.
   구조체 이름으로 값에 접근이 가능하기 때문
   ex) stockItem.Product.name

4. 구조체 비교할 때
	// 구조체가 같고 모든 필드가 동일하면
	// if p1 == p2
	// 이런식으로 비교가 가능한데,
	// 슬라이스 필드가 있으면
	// 비교가 불가능하다.

5. 익명 구조체를 함수에 정의 시
   동일한 구조를 가진 모든 구조체를 넘길 수 있게 되어
   함수 호출 시 동일한 로직을 실행할 수 있게 한다!

6. 포인터 구조체에 대한 값 접근(역참조) 시에
   * 없이도 접근이 가능하다

7. 포인터 필드가 있는 구조체의 복사
	// name은 다르지만, Supplier.city는 같아짐!!
	// 분명 구조체를 새로 복사해서 가져온건데 왜그럴끼?
	// 현재 PtrProduct 구조체 안에는 포인터 필드가 있음
	// 복사되면서 같은 Supplier를 바라보는 주소값이 복사됨
	// => PtrProduct는 다르지만, 같은 Supplier를 참조하게됨
   p292 그림 참조

    // => 내부의 포인터 변수에 대한 복사를 수행해야함
    // supplier := *p4.Supplier // 구조체 값 복사 후
	// p5.Supplier = &supplier  // 주소 넣어 주기

8. 포인터 변수는 기본값이 nil ‼️
   구조체 안에 포인터 필드가 있다면
   간단하게라도 정의해주는 게 좋음
   // => 해당 구조체를 제로 값으로 초기화 시 nil이 되기 때문 ‼️
   // prodSupp := PtrProduct{Supplier: &Supplier{}}